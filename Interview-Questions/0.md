- [Interview Questions](#interview-questions)
  - [Higher Order \& Callback function](#higher-order--callback-function)
  - [Array](#array)
    - [`Slice`](#slice)
  - [`Splice`](#splice)
  - [Closure](#closure)
    - [Example-01](#example-01)
    - [Example-02](#example-02)
    - [Example-03](#example-03)
    - [Example-04: Closure scope chaining using anonymous function](#example-04-closure-scope-chaining-using-anonymous-function)
    - [Example-05: Closure scope chaining without using anonymous function](#example-05-closure-scope-chaining-without-using-anonymous-function)
    - [Example-06](#example-06)
    - [Example-07](#example-07)
    - [Example-08](#example-08)
  - [Currying](#currying)
  - [Composition](#composition)
  - [IIFE](#iife)
    - [Avoid Polluting The Global Namespace](#avoid-polluting-the-global-namespace)
    - [Module Pattern - Create Priavate \& Public Variables \& Methods](#module-pattern---create-priavate--public-variables--methods)
  - [Promisification](#promisification)
  - [Iterator Pattern](#iterator-pattern)
  - [Generator Functions](#generator-functions)
  - [`yield` Keyword](#yield-keyword)

# Interview Questions

## Higher Order & Callback function

- A function that takes a function as an argument or return a function is called **Higher Order Function**
- The function I am taking as an argument is called **Callback**
- When should I use?
  - In the time consuming task

```js
function add(a, b, cb) {
  const result = a + b;
  cb(result); // Call the `cb` callback function
}

add(4, 5, (val) => {
  console.log(val);
});

// Output: 9
```

- `add` is higher order function & `cb` is a callback function
- A function returns a function is also called **Higher Order Function**

```js
function add(a, b, cb) {
  const result = a + b;
  cb(result); // Call the `cb` callback fn

  return () => console.log(result);
}

const resultFunction = add(4, 5, () => {}); // Just assign the received fn
resultFunction(); // Call that received fn

// Output: 9

// Another way
add(10, 20, () => {})(); // Assign & direct call the received fn

// Output: 30
```

- What is the problem of **Callback Function**?
  - Creates callback hell
- Already used **Higher Order Function** in JS?
  - `forEach`, `map`, `filter`, `find`, `findIndex` etc

## Array

### `Slice`

- Returns new array but no modification of existing array
- Includes `1`st index
- Excludes `4`th index

```js
const arr = [1, 2, 3, 4, 5, 7, 8];

console.log(arr.slice(1, 4));
// Output: [ 2, 3, 4 ]
```

- Ignore 2nd part then defines till the last

```js
const arr = [1, 2, 3, 4, 5, 7, 8];

console.log(arr.slice(4));

// Output: [ 5, 7, 8 ]
```

## `Splice`

- Removes the elements from an array
- Replaces those elements from some values
- Returns the removed elements
- So, modify the main array
- Includes `1`st index
- Excludes `4`th index

```js
const arr = [1, 2, 3, 4, 5, 7, 8];
const arr1 = [1, 2, 3, 4, 5, 7, 8];

console.log(arr.splice(1, 4, [10, 20])); // Output: [ 2, 3, 4, 5 ]
console.log(arr); // Output: [ 1, [ 10, 20 ], 7, 8 ]

console.log(arr1.splice(1, 4, 10, 20)); // Output: [ 2, 3, 4, 5 ]
console.log(arr1); // Output: [ 1, 10, 20, 7, 8 ]
```

## Closure

### Example-01

- A closure gives to access an outer function's scope from an inner function

```js
function main() {
  const name = 'Prince'; // local variable created by `main` fn

  function sayMyName() {
    // `sayMyName` is an inner fn that forms a closure
    console.log(name); // Use parent fn's variable
  }

  sayMyName();
}

main(); // Output: Prince
```

### Example-02

```js
const adder = (x) => {
  const inner = (y) => {
    console.log(x + y);
  };

  return inner;
};

const add5 = adder(5);
const add10 = adder(10);

add5(4); // Output: 9
add10(3); // Output: 13
```

### Example-03

```js
const makeCounter = () => {
  let count = 1;

  const increase = () => {
    console.log(count++);
  };

  return increase;
};

const counter = makeCounter();

counter(); // Output: 1
counter(); // Output: 2
counter(); // Output: 3
```

### Example-04: Closure scope chaining using anonymous function

```js
// global scope
const e = 10;
function sum(a) {
  return function (b) {
    return function (c) {
      // outer functions scope
      return function (d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

console.log(sum(1)(2)(3)(4)); // 20

// Alternate way
const fn1 = sum(1);
const fn2 = fn1(2);
const fn3 = fn2(3);
const result = fn3(4);
console.log(result); // Output: 20
```

### Example-05: Closure scope chaining without using anonymous function

```js
// global scope
const e = 10;
function sum(a) {
  return function sum2(b) {
    return function sum3(c) {
      // outer functions scope
      return function sum4(d) {
        // local scope
        return a + b + c + d + e;
      };
    };
  };
}

const sum2 = sum(1);
const sum3 = sum2(2);
const sum4 = sum3(3);
const result = sum4(4);
console.log(result); // 20
```

### Example-06

- Closures can capture variables in block scopes and module scopes as well
- For example, the following creates a closure over the block-scoped variable `y`:

```js
function outer() {
  let getY;
  {
    const y = 6;
    getY = () => y;
  }
  console.log(typeof y); // undefined
  console.log(getY()); // 6
}

outer();
```

### Example-07

- Closures over modules can be more interesting

```js
// myModule.js
let x = 5;
export const getX = () => x;
export const setX = (val) => {
  x = val;
};
```

- Even when x is not directly accessible from other modules, it can be read and written with the functions

```js
import { getX, setX } from './myModule.js';

console.log(getX()); // 5
setX(6);
console.log(getX()); // 6
```

### Example-08

- Closures can close over imported values as well, which are regarded as live bindings
- Because when the original value changes, the imported one changes accordingly
- `myModule.js`

```js
export let x = 1;
export const setX = (val) => {
  x = val;
};
```

- `closureCreator.js`

```js
import { x } from './myModule.js';

export const getX = () => x; // Close over an imported live binding
```

- Imported file

```js
import { getX } from './closureCreator.js';
import { setX } from './myModule.js';

console.log(getX()); // 1
setX(2);
console.log(getX()); // 2
```

## Currying

- Example-04 & 05 of Closure section
- TODO

## Composition

- TODO

## IIFE

- IIFE - Immediately Invoked Function Expression
- Another name - Self Executing Anonymous Function
- IIFE is a JS function that runs as soon as it is defined

```js
// Without parameters
(function () {
  console.log('This is IIFE');
})(); // Output: This is IIFE

// Arrow function
(() => {
  console.log('This is IIFE 2');
})(); // Output: This is IIFE

// With parameters
(function add(a, b) {
  console.log(a + b);
})(2, 3); // Output: 5

// Return value
const value = (() => 100)();
console.log(value); // Output: 100
```

### Avoid Polluting The Global Namespace

- It's a important to limit the number of global variables
- If we have some initiation code that we don't need to use again, we could use the IIFE pattern

```js
(functin () {
  // some initiation code
  let firstVariable;
  let secondVariable;
})();
```

- `firstVariable` & `secondVariable` will be discarded after the function is executed

### Module Pattern - Create Priavate & Public Variables & Methods

```js
const bank = (function (initialBalance) {
  let balance = initialBalance; // `balance` is private

  function withdraw(amt) {
    if (amt > balance) {
      return 'Are you kidding';
    } else {
      balance -= amt;
      return balance;
    }
  }

  return { withdraw };
})(1000);

// console.log(bank.balance); // undefined as `balance` is private

console.log(bank.withdraw(100));
console.log(bank.withdraw(100));
console.log(bank.withdraw(1000));
```

## Promisification

- It converts a function that accepts a callback into a function that returns a promise

## Iterator Pattern

- এটা এমন একটি ডিজাইন প্যাটার্ন যেটা কোনো collection (array, object, map, set) এর ভেতরের ডেটাগুলোকে একে একে traverse করতে সাহায্য করে, কিন্তু collection-এর internal structure ফাঁস না করেই।
- JS-এ Iterator এর দুইটা core concept:
  - Iterable → যেটাকে loop করা যায় (Array, String, Map, Set ইত্যাদি)
  - Iterator → actual implementation যে বলে দেবে পরের value কী

```js
{
  next() {
    return { value: ..., done: ... }
  }
}
```

## Generator Functions

- Generator হলো special type-এর function, যা "pause" এবং "resume" করা যায়। সাধারণ ফাংশনের মতো একবারে সব execute না হয়ে step-by-step চলে।

```js
function* myGenerator() {
  yield 1;
  yield 2;
  yield 3;
}
```

## `yield` Keyword

- Generator function-এর execution থামিয়ে দেয়
- একটি value return করে
- পরবর্তীতে `.next()` কল করলে ঠিক yield-এর পর থেকে execution আবার শুরু হয়

```js
function* counter() {
  let i = 1;
  while (true) {
    yield i;
    i++;
  }
}

const c = counter();
c.next(); // { value: 1, done: false }
c.next(); // { value: 2, done: false }
```

- ইন্টারভিউতে yield নিয়ে সাধারণ প্রশ্ন:
  - yield কি শুধু value return করে?
  - — না, execution pause করেও রাখে।
