- [Proxy](#proxy)
- [Reflect](#reflect)

# Proxy

- The `Proxy` object enables to create a proxy for another object
- It can intercept (বিচ্ছিন্ন করা) and redefine fundamental operations for that object
- Why need?

```js
const p = {
  age: 18,
};

// OK
p.age = 60;
p.newProperty = 'ABC';

// Need to prevent this
p.age = -10;
p.age = 'hello';
```

- So, no direct object access
- But instead create a proxy & give the access of that proxy object
- So that, I can prevent the invalid modification & changes
- Proxy Implementation

```js
const p1 = {
  fname: 'Rezoan',
  lname: 'Shakil',
  age: 12,
};

const p1Proxy = new Proxy(p1, {
  get: function (target, property) {
    if (property in target) {
      return target[property];
    }
    return false;
  },
  set: function (target, property, value) {
    if (!(property in target)) {
      throw new Error(`Property ${property} does not exist`);
    }

    switch (property) {
      case 'fname':
      case 'lname':
        if (typeof value !== 'string') {
          throw new Error(`${property} must be a string`);
        }
        break;
      case 'age':
        if (typeof value !== 'number') {
          throw new Error(`${property} must be a number`);
        }
        if (value < 0 || value > 150) {
          throw new Error(`${property} must be between 0 and 150`);
        }
        break;
    }
    target[property] = value;
  },
});

console.log(p1Proxy.age); // Output: 12

p1Proxy.fname = 'John'; // Valid
p1Proxy.age = 30; // Valid

try {
  p1Proxy.age = -5; // Invalid
} catch (e) {
  console.error(e.message); // Output: age must be between 0 and 150
}

try {
  p1Proxy.lname = 123; // Invalid
} catch (e) {
  console.error(e.message); // Output: lname must be a string
}

console.log(p1Proxy); // Output: { fname: 'John', lname: 'Shakil', age: 30 }
```

# Reflect

- Reflect contains static methods for invoking interceptable JavaScript object internal methods
- To avoid any buggy code

```js
const p1 = {
  fname: 'Rezoan',
  lname: 'Shakil',
  age: 12,
};

const p1Proxy = new Proxy(p1, {
  get: function (target, property) {
    if (property in target) {
      // return target[property];
      return Reflect.get(target, property); // Use of Reflect
    }
    return false;
  },
  set: function (target, property, value) {
    if (!(property in target)) {
      throw new Error(`Property ${property} does not exist`);
    }

    switch (property) {
      case 'fname':
      case 'lname':
        if (typeof value !== 'string') {
          throw new Error(`${property} must be a string`);
        }
        break;
      case 'age':
        if (typeof value !== 'number') {
          throw new Error(`${property} must be a number`);
        }
        if (value < 0 || value > 150) {
          throw new Error(`${property} must be between 0 and 150`);
        }
        break;
    }
    // target[property] = value;
    Reflect.set(target, property, value); // Use of Reflect
  },
});

console.log(p1Proxy.age); // Output: 12

p1Proxy.fname = 'John'; // Valid
p1Proxy.age = 30; // Valid

try {
  p1Proxy.age = -5; // Invalid
} catch (e) {
  console.error(e.message); // Output: age must be between 0 and 150
}

try {
  p1Proxy.lname = 123; // Invalid
} catch (e) {
  console.error(e.message); // Output: lname must be a string
}

console.log(p1Proxy); // Output: { fname: 'John', lname: 'Shakil', age: 30 }
```
